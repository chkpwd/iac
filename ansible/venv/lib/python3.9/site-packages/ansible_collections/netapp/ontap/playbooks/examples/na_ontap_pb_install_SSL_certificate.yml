# Example of installing a SSL certificate in ONTAP for authentication
# This playbook:
# 1. installs the certificate, or proceeds if the certificate is already installed,
# 2. enables SSL client authentication,
# 3. creates user account for cert authentication for ontapi and http applications,
# 4. validates that cert authentication works
#
# in test mode (using tags: -t all,testpb):
# 1b. the installation is repeated, to validate the check for idempotency (certificate already installed),
# 5. user account for cert authentication for ontapi and http applications is deleted,
# 6. if the certificate was installed in step 1, it is deleted.
# The certificate can be manually deleted using something like:
# security certificate delete -vserver trident_svm -common-name cert_user -ca cert_user -type *
#
# Prerequisites:
# you must have generated a certificate and have the certificate file (.pem) and the private key file available.
# This was tested using a self signed certificate:
# https://netapp.io/2016/11/08/certificate-based-authentication-netapp-manageability-sdk-ontap/
-
  name: Ontap Install SSL certificate and enable SSL certificate authentication
  hosts: localhost
  gather_facts: false
  collections:
    - netapp.ontap
  vars:
  # TODO: change these variable values from HERE to DONE:
    ontap_admin_ip: 10.XXX.XXX.X19
    ontap_admin_username: admin
    ontap_admin_password: XXXXXXXX
    # we recommend to use https, but it requires a valid SSL certificate
    ontap_use_https: true
    ontap_validate_certs: false

    # parameters to set up the certificate, ontap_cert_user must match the value of CN= when generating the certificate
    ontap_cert_user: cert_user
    ontap_cert_name: deleteme_cert
    # admin or vsadmin
    ontap_cert_role: vsadmin
    # admin or data SVM
    vserver: trident_svm
    # admin or SVM IP address (for admin, would the same as ontap_admin_ip)
    ontap_svm_ip: 10.XXX.XXX.X21
    # certificate and private key files
    cert_filepath: "/home/laurentn/atelier/ansible_wsl/ansible-playbooks/test.pem"
    key_filepath: "/home/laurentn/atelier/ansible_wsl/ansible-playbooks/test.key"
    # set this to false if the certificate is self-signed
    validate_certs_for_ssl_auth: false

    # you can either copy/paste the certificate(s) from the pem file, respecting the identation:
    ssl_certificate_inline: |
      -----BEGIN CERTIFICATE-----
      MXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxx
      XXXXXXXXxxxxxxxxXXXXXXXXxxxxxxxxXXXXXXXXxx==
      -----END CERTIFICATE-----

    # or read it directly from the pem file
    ssl_certificate_from_file: "{{lookup('file', cert_filepath)}}"

    # pick one:
    # ssl_certificate: "{{ ssl_certificate_inline }}"
    ssl_certificate: "{{ ssl_certificate_from_file }}"

  # DONE - do not change anything else (unless you really want to)

    # this will be used to authenticate using SSL certificate
    cert_login: &cert_login
      hostname: "{{ ontap_svm_ip }}"
      cert_filepath: "{{ cert_filepath }}"
      key_filepath: "{{ key_filepath }}"
      https: true
      validate_certs: "{{ validate_certs_for_ssl_auth }}"

    login: &login
      hostname: "{{ ontap_admin_ip }}"
      username: "{{ ontap_admin_username }}"
      password: "{{ ontap_admin_password }}"
      https: "{{ ontap_use_https }}"
      validate_certs: "{{ ontap_validate_certs }}"

  tasks:
    - name: run ontap info module to check connectivity
      na_ontap_info:
        <<: *login
        gather_subset: ontap_system_version
      register: ontap
    - debug: var=ontap.ontap_info.ontap_version

    - name: use ZAPIT to install certificate
      na_ontap_zapit:
        <<: *login
        zapi:
          security-certificate-install:
            cert-name: "{{ ontap_cert_name }}"
            certificate: "{{ ssl_certificate }}"
            type: client-ca
            vserver: "{{ vserver }}"
      ignore_errors: true
      register: ontap
    - debug: var=ontap
    - fail:
        msg: "Failed to install certificate: {{ ontap }}"
      when: ontap.failed and ontap.reason != "duplicate entry"
    - name: collect certificate data to be able to delete it later when testing
      tags: never,testpb
      set_fact:
        certificate_authority: "{{ ontap.response.ca | default('unknown') }}"
        serial_number: "{{ ontap.response.serial | default(0) }}"
        certificate_installed: "{{ not ontap.failed }}"
    - debug: var=certificate_authority
      tags: never,testpb
    - debug: var=serial_number
      tags: never,testpb
    - debug: var=certificate_installed
      tags: never,testpb

    - name: use ZAPIT to install certificate (idempotency)
      # use -t all,testpb when testing the playbook
      tags: never,testpb
      na_ontap_zapit:
        <<: *login
        zapi:
          security-certificate-install:
            cert-name: "{{ ontap_cert_name }}"
            certificate: "{{ ssl_certificate }}"
            type: client-ca
            vserver: "{{ vserver }}"
      ignore_errors: true
      register: ontap
    - debug: var=ontap
      tags: never,testpb
    - fail:
        msg: "Failed to install certificate: {{ ontap }}"
      tags: never,testpb
      when: ontap.failed and ontap.reason != "duplicate entry"

    - name: use ZAPIT to enable certificate authentication
      na_ontap_zapit:
        <<: *login
        zapi:
          security-ssl-modify:
            client-authentication-enabled: true
            vserver: "{{ vserver }}"
      register: ontap
    - debug: var=ontap
      tags: never,testpb

    - name: set up cert authentication for ontapi (ZAPI) and http (REST)
      na_ontap_user:
        <<: *login
        applications: ontapi,http
        authentication_method: cert
        name: "{{ ontap_cert_user }}"
        role_name: "{{ ontap_cert_role }}"
        vserver: "{{ vserver }}"
      register: ontap
    - debug: var=ontap
      tags: never,testpb

    - name: validate cert authentication is working for ZAPI
      na_ontap_info:
        <<: *cert_login
        gather_subset: ontap_version
      register: ontap
    - debug: var=ontap

    - name: remove cert authentication for ontapi (ZAPI) and http (REST) when testing
      tags: never,testpb
      na_ontap_user:
        <<: *login
        state: absent
        applications: ontapi,http
        authentication_method: cert
        name: "{{ ontap_cert_user }}"
        role_name: "{{ ontap_cert_role }}"
        vserver: "{{ vserver }}"
      register: ontap
    - debug: var=ontap
      tags: never,testpb

    - name: use ZAPIT to delete certificate when testing
      # use -t all,never when testing the playbook
      tags: never,testpb,delete
      na_ontap_zapit:
        <<: *login
        zapi:
          security-certificate-delete:
            certificate-authority: "{{ certificate_authority }}"
            common-name: "{{ certificate_authority }}"
            serial-number: "{{ serial_number }}"
            type: client-ca
            vserver: "{{ vserver }}"
      when: certificate_installed
